# Greedy
그리디 알고리즘은 동적 프로그래밍 사용 시 지나치게 많은 일을 한다든 것에서 착안하여 고안된 알고리즘이다.

동적 프로그래밍을 대체하는 것은 아니고 같이 쓰이며 서로 보완하는 개념이다.

그리디 알고리즘은 탐욕 알고리즘 또는 욕심쟁이 알고리즘이라고도 불리는데요. 미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법.

각 단계에서 최선의 선택을 한 것이 전체적으로 최선이길 바라는 알고리즘.

<img width="775" alt="스크린샷 2022-07-24 오후 4 13 10" src="https://user-images.githubusercontent.com/82895809/180636602-92d59045-70f5-4c66-a128-f7cdf23d3f67.png">

물론 모든 경우에서 그리디 알고리즘이 통하지는 않는다.

## 탐욕 알고리즘 문제를 해결하는 방법
1. 선택 절차(Selection Procedure): 현재 상태에서의 최적의 해답을 선택한다.
2. 적절성 검사(Feasibility Check): 선택된 해가 문제의 조건을 만족하는지 검사한다.
3. 해답 검사(Solution Check): 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복한다.

### 탐욕 알고리즘을 적용하려면 문제가 다음 2가지 조건을 성립하여야 한다.
* 탐욕 알고리즘이 잘 작동하는 문제는 대부분 탐욕스런 선택 조건(Greedy Choice Property)과 최적 부분 구조 조건(Optimal Substructure)이라는 두 가지 조건이 만족된다.
* 탐욕스런 선택 조건은 앞의 선택이 이후의 선택에 영향을 주지 않는다는 것이며, 최적 부분 구조 조건은 문제에 대한 최적해가 부분문제에 대해서도 역시 최적해라는 것이다.

1. 탐욕적 선택 속성(Greedy Choice Property) : 앞의 선택이 이후의 선택에 영향을 주지 않는다.
2. 최적 부분 구조(Optimal Substructure) : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다.

* 이러한 조건이 성립하지 않는 경우에는 탐욕 알고리즘은 최적해를 구하지 못한다.
* 하지만, 이러한 경우에도 탐욕 알고맂므은 근사 알고리즘으로 사용이 가능할 수 있으며, 대부분의 경우 계산 속도가 빠르기 때문에 실용적으로 사용할 수 있다.
* 이 경우 역시 어느 정도까지 최적해에 가까운 해를 구할 수 있는지를 보장하려면 엄밀한 증명이 필요하다.
* 어떤 특별한 구조가 있는 문제에 대해서는 탐욕 알고맂므이 언제나 최적해를 찾아낼 수 있다.
* 이 구조를 매트로이드라 한다.
* 매트로이드는 모든 문제에서 나타나는 것은 아니나, 여러 곳에서 발견되기 때문에 탐욕 알고리즘의 활용도를 높여준다.

> 탐욕 알고리즘은 항상 최적의 결과를 도출하는 것은 아니지만, 
> 어느 정도 최적에 근사한 값을 빠르게 도출할 수 있는 장점이 있다. 
> 이 장점으로 인해 탐욕 알고리즘은 근사 알고리즘으로 사용할 수 있다.

> 탐욕 알고리즘을 적용해도 언제나 최적해를 구할 수 있는 문제(매트로이드)가 있고, 
> 이러한 문제에 탐욕 알고리즘을 사용해서 빠른 계산 속도로 답을 구할 수 있다. 
> 그래서 실용적으로 사용할 수 있다.

## 근사 알고리즘(Approximation Algorithm)
* 근사 알고리즘은 어떤 최적화 문제에 대한 해의 근삿값을 구하는 알고리즘을 의미한다.
* 이 알고리즘은 가장 최적화되는 답을 구할 수는 없지만, 비교적 빠른 시간에 계산이 가능하며 어느 정도 보장된 근사핼르 계산할 수 있다.

## 그리디 알고리즘 문제
가장 일반적인 문제의 예는 거스름돈 문제가 있다.

### 거스름돈 문제
> 당신은 음식점의 계산을 도와주는 점원입니다. 
> 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원 동전이 무한개 존재합니다. 
> 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러주어야 할 동전의 최소 개수를 구하라. 
> 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.

이 문제에서 우리가 생각할 수 있는 것은 **'가장 큰 단위의 돈부터 생각하자'** 이다. 

만약 2240원이라는 돈을 거슬러 줘야 한다고 가정하면 이 돈을 거슬러 줄 수 있는 방법은 많다.

```java

    public int solution(int money) {
        int answer = 0;
        int[] change = { 500, 100, 50, 10 };
        int remain = money;
        for (int i : change) {
            answer += remain / i;
            remain = remain % i;
        }
        return answer;
    }
```

그리디 알고리즘을 사용해 답을 찾게 된다면, 그 답이 정당한지 생각해봐야한다.

거스름돈 문제는 가지고 있는 동전 중 '큰 단위'의 동전이 항상 '작은 단위'의 배수이므로 (500 = 100 * 5, 100 = 50 * 2, 50 = 10 * 5) 작은 단위 동전을 조합해 다른 해가 나올 수 없기 때문에 사용할 수 있다.


